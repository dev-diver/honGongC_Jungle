# CH19 전처리와 분할 컴파일

## #include

- “”  ,<> 차이. 헤더 파일 검색 우선순위
    - <> - 컴파일러가 미리 설정한 include 디렉터리에서 먼저 검색함
    - “” - 소스파일이 저장된 디렉터리에서 먼저 파일을 찾음
        - 경로 지정시 백슬래시 이스케이프 안해줘도 된다 (컴파일러가 처리하는 것이 아님)
    - `repl.it`에서 그냥 파일 `헤더파일.h` 로 저장하면 됨
- 모듈 - 독립적으로 컴파일 가능한 단위
- `#include` 는 파일의 내용을 단순 복사한다
    - 텍스트 형태의 파일이면 모두 사용할 수 있다.
    - 심지어 함수 중간에 소스코드 파일도 들어가게 할 수 있다 → 특별한 이유없이 이렇게 하지는 말자. (왜?)

## #define

- 매크로명을 정의
    
    `#define 매크로명 치환될_부분`
    
- 관럐상 대문자로 쓴다 → 다른 변수명과 구분할 수 있도록
- 문제가 발생하면 매크로가 어떻게 최환되는지 확인해야함 → 디버깅. 유지보수가 힘듬
- 필요한 경우에만 제한적으로 쓰는 것이 좋음
- 매크로 함수는 호출한 함수로 이동할 때 필요한 준비작업이 없음(컴파일시 모두 완료)
    - 크기가 작은 함수를 자주 호출한다면 매크로 함수가 도움이 됨

## 문법

### 기본

```c
#define PI 3.1415 //매크로 상수
#define MSG "Passed!"  //매크로 상수(문자열)
#define ERR_PRN printf("경고") //문장 치환

#define INTRO "Perfect C Language \   //여러줄 쓸 때는 백슬래시 '/'
& Basic Data structure"
```

### 매크로 함수

```c
#define 매크로_함수명(인수) 치환될_부분

#define SUM(a,b) ((a)+(b))
```

- 치환의 부작용 예방
    - 괄호를 써서 정의
    - 치환될 인수 모두에 괄호 붙이기
- 부작용의 예
    
    ```c
    #define MUL(a,b) a*b  -> res=3/MUL(2,5)
    #define MUL(a,b) (a*b) -> MUL(2,2+3)
    ```
    

## 이미 정의된 매크로

- 대부분 언더바 `_` 두개가 감싸고 있다.
- 프로그램 예상치 못한 종료시 함수명, 행번호를 출력할 수 있다.(디버깅에 활용되나?)

### 종류

- #line 행수 (파일멍) : 파일명과 라인명을 출력할 수 있음.
- __FILE__:전체 디렉터리 경로를 포함한 파일명
- __FUNCTUION__:매크로명이 사용된 함수 이름
- __LINE__: 매크로명이 사용된 행 번호
- __DATE__: 컴파일을 시작한 날짜
- __TIME__: 컴파일을 시작한 시간

## 매크로 연산자 #과 ##

```c
#define PRINT_EXPR(X) printf(#x "=%d\n",x)
PRINT_EXPR(a1+a2) -> printf("a1+a2" "=%d\n", a1+a2)
//컴파일러는 여러개의 문자열을 연속으로 사용하면 하나의 문자열로 연결해 처리함.

#define NAME_CAT(x,y) (x ## y)
NAME_CAT(a,1) = 10; -> a1 = 10;
```

- #은 문자열로 치환
- ##은 인자(토큰;token)끼리 합쳐줌 (인자 여러가지로 조합할 때 활용)
    - 토큰: 프로그램에서 독립된 의미를 갖는 하나의 단위
    - 토큰 예시?

## 기타 매크로

```c
#if    //조건식으로 매크로명만 사용할 수 있다.  변수는 사용 못함
#else
#elif
#endif

#ifdef   // =   #if defined
#ifndef // =   #if !defined  =  #if undefined

#error 에러메시지  //에러메시지를 보여주고 컴파일 종료  (#if와 함께 쓰자)

#pragma  //컴파일 방법 세부적 제어
#pragma pack(push,1)  // 바이트 얼라이먼트를 1로 바꿈
#pragma pack(pop) //바이트 얼라이먼트를 되돌림
#pragma pack(1) //바이트 얼라이먼트를 1로 바꿈

#pragama warning(disable:4101)  //4101 경고를 표시하지 않음
```

- 매크로 조건식
    - 정수 상수나 정수로 치환되는 매크로 상수로 만든식만 사용 가능
    - 변수는 사용 못함
    - 조건식에 괄호는 생략해도 된다.

## 분할 컴파일

- 조건
    - 개별적으로 코드를 작성하고 컴파일 및 에러 수정을 할 수 있어야 한다.
        - 필요한 선언을 포함해야 한다.
    - 각 개발자들 간의 데이터 공유와 코드 재활용이 가능해야 한다.
- 이미 만들어진 소스 파일이나 컴파일된 개체도 프로젝트에 포함될 수 있다.
- `[repl.it](http://repl.it)` 에서 알아서 분할 컴파일 해줌.

## extern, static

- extern - 외부 파일에 선언된 전역변수를 가져옴
    - extern 선언시 초기화 못함 (컴파일러에 따라 할 수 있어도 하지 말자)
    - 지역변수로도 쓸 수 있나? → 애초에 지역변수로 extern을 할 필요가 없다.
- 전역변수의 static - 외부에서 extern 으로 가져가지 못함
    - extern 시 중복 이름을 방지하는 효과가 있다.
    - 다른 파일에서 같은 변수명을 쓸 수도 있으니, 외부 공유가 필요하다고 합의된 변수가 아니라면 static을 꼭 붙이자!
    - 전역변수이므로, 같은 모듈내 함수에서 값을 계속 재활용 할 수 있다! (확인문제 1)
- 함수 선언에서는 기본적으로 extern이 생략됨
    - 원현 선언만으로 다른 파일의 함수를 호출할 수 있다.
    - 같은 모듈에서만 쓰고 싶다면 static을 붙이자.
- 데이터 공유 부분 다시보기!

## 헤더파일의 필요성

- 다른 모듈의 함수 선언 반복
- 전역 변수 여러 파일에서 공유 - 초기화를 하지 말자
- 구조체 선언 반복

### 중복 해결이 필요함 - 조건부 컴파일

- include 한 파일이, 내가 include한 파일을 공통으로 include하고 있을 때 중복 발생
- 함수 선언, extern 선언은 중복 선언이 가능함
- 구조체 선언은 중복 선언이 불가능함

```c
//so smart!  sigleton pattern?
#ifndef _POINT_H_
#define _POINT_H_

typedef struct{

}Point

#endif
```

## 문제

1. extern 선언은 중복이 가능하므로 헤더 파일에 넣어 사용하는 것이 좋다?
2. 헤더파일에서 초기화한 전역변수 선언은 헤더 파일이 여러 파일에 인클루드되었을 때 중복 문제가 발생한다.

## 궁금한 것

- 매크로치환이 꼭 필요한 경우가 있을까?
- 링커가 링크만 한다는 건 무슨 말일까?
    - 함수선언만 해둔 헤더파일 따로
    - 함수가 실제로 있는 파일 따로
- VSC 에서 분할 컴파일하기
- static 과 private 관계?
- 조건부 컴파일과 singleton pattern의 관계