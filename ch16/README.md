# CH16 메모리 동적 할당

## 필요한 이유

- 데이터 종류나 수를 장담할 수 없는 경우
- 실행 도중에 동적으로 메모리를 확보
    - 데이터 맞춤 프로그래밍이 가능함.
    - 메모리 낭비가 줄어듬
- 동적 메모리 할당은 고급 프로그래밍 테크닉으로 들여가는 열쇠다(*C Primer Plus*)

## 주의

- malloc 함수의 반환값이 널 포인터인지 반드시 확인하고 사용해야 한다.
    - 검사하지 않으면 평소에 잘 실행되던 프로그램이, 갑자기 메모리 부족해 문제가 될 수 있다.
- 사용이 끝나면 재활용 할 수 있도록 반환해야 한다.
    - 메모리 누수 방지
    - 함수가 반환되어도 메모리 회수가 되지 않는다!
        - 실험코드

## 궁금한 것

- 메모리 확보에 실패하는 경우도 있나?
- 컴파일 할 때 메모리 확보에 실패할 수는 없나?
- exit과 return의 차이
- 메모리가 부족하면 무조건 실행 종료하는지? - 알수 없음. 어쨌든 불안정함(*GPT*)
    - 프로그램 종료
    - 메모리 오류 또는 예외 발생 (Out of Memory)
    - 스왑 아웃 또는 페이지 파일 사용 - 디스크로 스왑
- calloc은 왜 이름에 contiguous가 들어갔는지?(malloc도 연속적인데?)
    - calloc은 다음 코드를 수행하는 것과 같다. (*cFAQ*)
    
    ```c
    p=malloc(m*n);
    memset(p,0,m*n);
    ```
    
    - calloc이 만들어진 이유(*GPT*)
        - 메모리 초기화 → 배열이나 구조체 같은 데이터 구조를 초기화 하는데 유용하다.
        - 요소 수와 크기 지정 → 배열을 생성하거나 다차원 배열을 생성하는데 특히 유용
    - 개인적인 생각 - malloc이 calloc보다 편한 경우
        - 동적 문자열 할당
        - 단일 변수 할당 (왜 쓰는지 모르겠음)
        - 동적으로 크기가 조절되는 단일 데이터 구조 생성
- realloc 할 때 주소가 바뀌는 경우는 어떤 경우인지?(*GPT*)
    - 메모리 크기가 늘어나거나 줄어들 때
        - 늘어나야 하는데, 부족할 때
        - 블록 작아질 때, 심시티함
    - 메모리 재배치 - 메모리 관리자가 내부적으로 블록을 재배치해야 하는 경우
- malloc casting 안 해줘도 된다?
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    
    int main(void) {
    
      int *pi;
      pi = malloc(sizeof(int));
      if(pi==NULL)
      {
        printf("#메모리가 부족합니다.\n");
        exit(1);
      }
      *pi = 10;
      printf("%d\n",*pi);
      
      return 0;
    }
    ```
    
    - void형을 쓸 수 있다면, malloc casting 안 해줘도 된다!

## C-FAQ

- calloc에서의 0이 null이나 실수에서 0이 아닐수도 있다?
- 흥미로움 - null 예외 처리를 하는 malloc wrapper() 만들기
- 쓸 수 있는 메모리가 얼마나 남았는지 확인?
- malloc(0)?