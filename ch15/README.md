# CH15 응용 포인터

## 배열 포인터

```c
int (*pa)[4];   
```

- 포인터가 가리키고 있는 자료의 type을 알려주는데 의의가 있는 것 같다.
    - 주소 연산을 type에 따라서 다르게 하기 때문에
    
    ```c
    int[4] *pa  //이게 더 맞는 표현이 아닐까 하는데
    char ch[4]  //다른 배열명들도 이렇게 쓰고,
    int *pa[4] // 이건 이미 포인터 배열이므로 
    
    int (*pa)[4] //  *pa를 배열명으로 하는 int형 4개의 배열이라고 해석해서 암기
    ```
    
    - 괄호로 묶는 것은, 이 선언이 ‘포인터의 선언’이라는 것을 알려줌

## 함수 포인터

- 기능은 다르지만 형태가 같은 함수를 선택적으로 호출할 때 필요
    - **함수를 매개변수처럼 이용**
    - 함수 포인터를 이용하는 함수를 만드는 시점에 연산 방법을 결정할 수 없는 경우
    - 하나의 프로그램이 여러 개의 파일로 분리되어 있는 경우 (정적 함수를 호출한다.)  ?
- 함수명도 함수 정의가 있는 메모리의 시작 위치 (즉. 주소다)

### 문법

```c
int (*fp)(int, int);  //포인터임을 나타내기 위해 괄호로 변수를 * 와 묶는다.

//다음은 포인터를 반환하는 함수의 선언
int *fp(int, int);
```

## Void포인터

- 가리키는 자료형이 다른 주소를 저장하는 경우 void포인터 사용
- 가리키는 자료형 결정을 보류함
- 자료형과 독립된 코드 만들 수 있음
    
    ```c
    void *p
    vp=&a;
    printf("a :%d",*(int *)vp); //포인터 형 변환 필요
    ```
    
- 포인터 연산, 정수연산은 불가능
- 형 변환을 하면 포인터 연산 가능
- 다른 포인터에 대입할 때는, void를 다른 포인터로 형변환 하지 않아도 된다.
    - 하지만 명시적으로 해주는 것이 버그 확률을 줄인다.
    
    ```c
    int *pi = (int *)vp;
    ```
    

### 활용 예

- 동적 메모리 할당